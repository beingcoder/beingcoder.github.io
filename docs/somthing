
ESI（Edge Side Include） 。
ESI来做动态页面中相对静态的片段部分的缓存。

jenkins/swarm

puppet/saltstack
ldap+kerberos实现单点登录--实验
Squid 
nginx
osprey+mission
分布式日志系统
cpulimit
zabbix
nagios 
saltstack linux/windows/macOS

rules
install pkg/autodeployment.
ldap/user/group/hostgroup
function ID management.
service group/mail notification/tray tools
CI/CD
jbpm

docker

job schedular:
Job Arranger for Zabbix
Schedulix 
RUNDECK

yaml
physical/docker


dockerfile




gitlab
$ git config --global user.name "Your Name"
$ git config --global user.email "email@example.com"

ssh-keygen
~/.ssh/

git 
 init, add, commit, diff, status, log, reflog,rm,clone,tag,fetch
 git reset --hard HEAD^
 git log --graph
 git checkout -- file 丢弃工作区的修改时
 git checkout  其实是用版本库里的版本替换工作区的版本，无论工作区是修改还是删除
 git reset HEAD file  丢弃暂存区的修改时时
 git remote add origin git@github.com:michaelliao/learngit.git
 git push -u origin master 
 第一次推送master分支时，加上-u参数，还会把本地的master分支和远程的master分支关联起来，在以后的推送或者拉取时就可以简化命令
 
查看分支：git branch
创建分支：git branch <name>
切换分支：git checkout <name>
创建+切换分支：git checkout -b <name>
合并某分支到当前分支：git merge <name>   --no-ff 合并后的历史有分支
删除分支：git branch -d <name>
 
 git stash list/git stash apply/git stash drop
 工作现场git stash一下，然后去修复bug，修复后，再git stash pop，回到工作现场
 
查看远程库信息，使用git remote -v；
本地新建的分支如果不推送到远程，对其他人就是不可见的；
从本地推送分支，使用git push origin branch-name，如果推送失败，先用git pull抓取远程的新提交；
在本地创建和远程分支对应的分支，使用git checkout -b branch-name origin/branch-name，本地和远程分支的名称最好一致；
建立本地分支和远程分支的关联，使用git branch --set-upstream branch-name origin/branch-name；
从远程抓取分支，使用git pull，如果有冲突，要先处理冲突。

Crane|FIG

Foreman is an open source project that helps system administrators manage servers throughout their lifecycle, from provisioning and configuration to orchestration and monitoring. Using Puppet, Chef, Salt, and Foreman's smart proxy architecture, you can easily automate repetitive tasks, quickly deploy applications, and proactively manage change, both on-premise with VMs and bare-metal or in the cloud.


javascript VNC library noVNC, which allows clientless VNC within a web browser.

.gitignore

job schedular:
Job Arranger for Zabbix
Schedulix 
RUNDECK

Bloodhound vs Bugzilla, mantis，redmine, bugfree

ldap
udeploy
hermes
autosys
cloud
git/gitlab
mesos
spark
Packer



Packer from Hashicorp is a really nice tool that allows you to create many different (cloud) images from a single definition.
 
Chronos 是一个具备容错特性的作业调度器

SPNEGO 

nsupdate

flannel: Developed by the CoreOS team, this project was initially developed to provide each host system with its own subnet of a shared network. This is a condition necessary for Google's kubernetes orchestration tool to function, but it is useful in other situations.
weave: Weave creates a virtual network that connects each host machine together. This simplifies application routing as it gives the appearance of every container being plugged into a single network switch.

https://github.com/mesosphere/playa-mesos

Ext2Fsd EasyBCD

pxe
cobble


从模块化的角度来说，以Mesos为基础的数据中心OS的构成是这样的：
核心(Mesos)，
分布式初始化脚本(Marathon/Aurora)，
计划任务工具(Chronos)等。

分布式架构：动静分离，  读写分离 ，  异步化， 垂直切分，  水平切分， 缓存，  负载均衡。

服务发现工具：
etcd ：这是CoreOS的创建者提供的工具，面向容器和宿主机提供服务发现和全局配置存储功能。它在每个宿主机上有基于http协议的API和命令行的客户端。
consul ：这个服务发现平台有很多高级的特性，使得它脱颖而出，例如：配置健康检查、ACL功能、HAProxy配置等等。
zookeeper ：这个工具较上面两个都比较老，提供一个更加成熟的平台和一些新特性。

一些基本服务发现工具的扩展项目：
crypt ：Crypt允许组件通过采用公钥加密的方式来保护它们的信息。需要读取数据的组件会被分配密钥，而其他组件则不能读取数据。
confd ：Confd项目旨在基于服务发现的变化，而动态重新配置任意应用程序。该系统包含了一个工具来监测节点中的变化、一个模板系统来根据获取到的值来生成配置文件，并能够重新加载受影响的应用。
vulcand ：Vulcand为成组的组件作为负载均衡使用。它使用etcd作为后端，并基于监测变更来调整它的配置。
marathon ：虽然marathon主要是调度器（后续介绍），它也实现了一个基本的重加载HAProxy的功能，当发现变更时它来协调可用的服务。
frontrunner ：这个项目嵌入在marathon中对HAProxy的更新提供一个更稳定的解决方案。
synapse ：这个项目引入了嵌入式的HAProxy组件，它能够路由流量给各个组件。
nerve ：它被用来与synapse结合一起来为各个组件提供健康检查，如果组件不可用，nerve将更新synapse将该组件移除出去。

mesos（资源调度）
marathon（服务编排）
chronos（分布式计划任务）
docker（容器引擎）
consul+registrator（服务注册和发现）
haproxy（负载均衡）
prometheus（服务监控）
nagios/zabbix（节点监控）
salt（节点配置管理）
cobbler（节点自动化装机）
ELK（日志收集分析）


Docker Registry ,Nginx 负载多个 Registry

使用网络存储共享镜像,配置 Mirroring，获取官网镜像

http://www.linuxde.net/2014/12/15647.html
双机高可用、负载均衡、MySQL(读写分离、主从自动切换)架构设计

http://www.tuicool.com/articles/Ibayiq
通过APACHE MESOS在生产环境中使用Docker

mysql atlas  读写分离
mysql GTID 全局事务ID

IP pool
DNS pool

nis  netgroup

mesos-dns

zookeeper
etcd
NAS共享

ELK三剑客，即Elasticsearch、Logstash和Kibana

BlueGreenDeployment

Fleet：Fleet是一个通过Systemd对CoreOS集群进行控制和管理的工具。如果你想启动容器或者手动指定映射到主机的端口，那Fleet是一个不错的选择（译者注：Fleet的更多资料可以阅读本文）。
Kubernetes：这可能是最佳的选择之一，但现在Kuernetes还太年轻。
Mesos：Mesos目前已经支持Docker，它已经是一个相对稳定的平台，并且可以用来部署其它软件，例如Hadoop。

spring.test
@Before
    public void setUp() throws NamingException {
        dataSource = new EmbeddedDatabaseBuilder().setType(EmbeddedDatabaseType.HSQL).setName("springtestdb").build();
        contextBuilder = SimpleNamingContextBuilder.emptyActivatedContextBuilder();
        contextBuilder.bind("java:jdbc/myDataSource", dataSource);
        contextBuilder.bind("java:comp/UserTransaction", new J2eeUserTransaction());
        contextBuilder.bind("persistence/MyPersistenceUnit", createEntityManagerFactory());
    }
 
    private EntityManagerFactory createEntityManagerFactory() {
        Map<String, String> properties = new HashMap<String, String>();
        properties.put("hibernate.hbm2ddl.auto", "create-drop");
        properties.put("javax.persistence.transactionType", "RESOURCE_LOCAL");
        EntityManagerFactory entityManagerFactory = Persistence.createEntityManagerFactory("MyPersistenceUnit", properties);
        return entityManagerFactory;
    }
	
	空间换时间: 多级缓存，静态化(反向代理缓存,应用端的缓存(memcache),内存数据库)
	索引:哈希、B树、倒排、bitmap
	并行与分布式计算:
	    1,数据分解,  Map/reduce(利用局部性的原理将海量数据计算的问题分而治之。)
		2,基于问题分解的, 多进程、多线程并行执行
	多维度的可用
		1,负载均衡、容灾、备份
		2,读写分离
		3,依赖关系,低耦合的，能异步则异步; 确认机制,重发考虑幂等性
	监控
	伸缩
		 拆分(业务的拆分,数据拆分) e.g. 主域名和图片域名分离,减少读取cookie对图片服务器的压力
		 无状态
	优化资源利用
		考虑流量的控制，防止因意外攻击或者瞬时并发量的冲击导致系统崩溃。
		原子操作与并发控制,保证并发控制一些常用高性能手段有，乐观锁、Latch、mutex、写时复制、CAS等；多版本的并发控制MVCC通常是保证一致性的重要手段
		基于逻辑的不同，采取不一样的策略,e.g.针对IO型的，可以采取基于事件驱动的异步非阻塞的方式，单线程方式可以减少线程的切换引起的开销，或者在多线程的情况下采取自旋spin的方式，减少对线程的切换(比如oracle latch设计)；对于计算型的，充分利用多线程进行操作。
		容错隔离, 自治模块,暂时的失败,需要进行请求重试的考虑
		资源释放,e.g. 在设计通信的架构时，往往需要考虑超时的控制。
		
	剖析架构:
	    CDN:
		负载均衡、反向代理缓存,4层(LVS+Keepalived/Heartbeat),7层Nginx,HAProxy,squid
		会话控制:反向代理或者负载均衡支持session sticky 或者 session的集中式存储
		业务服务: DDD,参考高内聚、接口收敛的原则;对外协议以NIO的RPC方式得道高并发，netty/mina
		数据库切分: Shard,   vertical/horizon/ master&slave
		HA:Heartbeat、keepalived,zookeeper
		消息Message:kafka/rabbitMQ,总体来讲，RabbitMQ用在实时的对可靠性要求比较高的消息传递上。kafka主要用于处理活跃的流式数据,大数据量的数据处理上
		Cache系统:redis比,memcache
		Buffer系统: producer/consumer,     blocking queue,  disruptor,  simple single thread batch.(batch size/fetch size on jdbc)
		搜索:lucene
		日志收集:
		数据同步:
		数据分析:
		实时计算:
		实时推送: comet
	管理与部署配置
		统一的配置库,部署平台
		监控、统计
		
	
events are very domain-focused,Commands are focused around what the user considers as an operation		

zookeeper

ris for linux

supervisory process such as daemontools or SMF 
supervisord

vagrant 
Panamax 
Mesos/marathon
kubernetes

curl
nc

Apache Directory Studio

production env,

developer should have very limited access priviledge for production.

prod db backup everyday,  and then anyone can restore it on non-production env on demand(OA approve).

production current configuration(software installation, resource monitor)
打通开发和运维的最低栅栏。

log management.


reinstall os,  
wiki

JSR 303 Bean Validation based validation

在容器前使用负载均衡
opencv
Aparapi
OpenCL  CUDA
Sparknotebook

scp  bpmuser@dbvdev4133.uk.standardchartered.com:/home/bpmuser/.ssh/id_rsa.pub ./

StringBuffer/StringBuilder/Connections  初始长度好重要

字符串连加等同于StringBuilder.append.append.  但只管一条指令。

对于不知道要不要输出的日志，交给slf4j在真的需要输出时才去拼接的确能省节约成本。
但对于一定要输出的日志，直接自己用StringBuilder拼接更快

System.exit(0)会跳过finally块的执行

id_rsa.pub

scp bpmuser@dbvdev4133.uk.standardchartered.com:/bpmshare/SHAPE/DEV/logpars/LogParser/LogParser.jar ./home/bpmuser/.ssh/
scp ORDM_Data_Extract-release.tar scrit2w@10.192.103.218:/tmp	

scp *.gz bpmuser@10.27.147.4:/dev/shm/dashboard

bookmark
4.2. Aggregate

An Aggregate is an entity or group of entities that is always kept in a consistent state. The aggregate root is the object on top of the aggregate tree that is responsible for maintaining this consistent state.




请注意命令是发送而非发布——这是有区别的。命令是发送的，事件是发布的。当事件被发布后，发布者只是声明了一个状态，它的工作就此结束。至于接受者要拿事件做什么处理，发布者并不关心。


DDL(不可回滚)是不能参与到两阶段事务提交的， 因为两阶段提交的第二阶段是有可能回滚的. 

仿真两阶段提交可以支持DDL,  但有些AppServer 只支持一个non-xa的数据源
在获取数据源时，使用JNDI绝对路径和相对路径可能会造成AppServer认为是不同的数据源 ， 虽然他们实际是指向同一个数据源。


Although Domain Events technically indicate a state change, you should try to capture the intention of the state in the event, too. A good practice is to use an abstract implementation of a domain event to capture the fact that certain state has changed, and use a concrete sub-implementation of that abstract class that indicates the intention of the change. 

Although Domain Events technically indicate a state change, you should try to capture the intention of the state in the event, too. A good practice is to use an abstract implementation of a domain event to capture the fact that certain state has changed, and use a concrete sub-implementation of that abstract class that indicates the intention of the change. For example, you could have an abstract AddressChangedEvent, and two implementations ContactMovedEvent and AddressCorrectedEvent that capture the intent of the state change. Some listeners don't care about the intent (e.g. database updating event listeners). These will listen to the abstract type. Other listeners do care about the intent and these will listen to the concrete subtypes (e.g. to send an address change confirmation email to the customer).

For example, a "Contact" aggregate could contain two entities: Contact and Address. To keep the entire aggregate in a consistent state, adding an address to a contact should be done via the Contact entity. In this case, the Contact entity is the appointed aggregate root.

isAssignableFrom versus instanceof
Note that the code sample used isAssignableFrom to verify the payload type of a command. This method is preferred over "getPayload() instanceof" for performance reasons. When reading events from the Event Store, they are actually not deserialized until the getPayload() method is invoked. By using getPayloadType() to detect interesting Events, you skip deserialization for events that you are not interested in.

bootstrap
mathjax
fontawesome

jquery plugins: toc,  table , tree, editabletable, ordertable,draggabletable

persistJS/pStorage

 Typically, it is a bad idea to use return values to return server-generated identifiers. Consider using client-generated (random) identifiers, such as UUIDs. They allow for a "fire and forget" style
 
 LinkedList   size()==0   vs  isEmpty()
 
 

微博关注按钮、百度分享、多说评论系统

 /**
     * Creates an empty property list with the specified defaults.
     * @param   defaults   the defaults.
     */
    public Properties(Properties defaults) {
        this.defaults = defaults;
    }

SpringJdbcTemplate RowMapper 

Chrome supports  DOM,Event Listener,XHR breaks
	
1201 9260 26342

MathJax。这是一个基于JavaScript的Latex渲染引擎，它将网页中的Latex公式转变成多个不同字体的文字或图片的组合。

disk unlock,
1, call 46248 to create a ticket,   ask them to assign it tianjin hub IT support, write down the req num.
2, call 6666 to review the ticket.
3, call 46248 again to ask them to assign the ticket to SAS
4, call 5820 or 6764 to ensure the request is fullfilled.
5, line manager will receive a mail which contain a token
6, on login windows,  press F4 then input that token.
7, what's a day.

bootstrap
p class="lead"，这将得到更大更粗、行高更高的文本
<small>（设置文本为父文本大小的 85%）、<strong>（设置文本为更粗的文本）、<em>（设置文本为斜体）
 

.lead	使段落突出显示
.small	设定小文本 (设置为父文本的 85% 大小)
.text-left	设定文本左对齐
.text-center	设定文本居中对齐
.text-right	设定文本右对齐
.text-justify	设定文本对齐,段落中超出屏幕部分文字自动换行
.text-nowrap	段落中超出屏幕部分不换行
.text-lowercase	设定文本小写
.text-uppercase	设定文本大写
.text-capitalize	设定单词首字母大写
.initialism	显示在 <abbr> 元素中的文本以小号字体展示
.blockquote-reverse	设定引用右对齐
.list-unstyled	移除默认的列表样式
.list-inline	将所有列表项放置同一行
.dl-horizontal	该类设置了浮动和偏移，
.pre-scrollable	使 <pre> 元素可滚动 scrollable

<abbr title="Real Simple Syndication" class="initialism">RSS</abbr>
<address/>
<blockquote class="pull-right">这是一个向右对齐的引用。<small>Someone famous in <cite title="Source Title">Source Title</cite></small></blockquote>
<ul/>  <ol/>

<ul class="list-inline">内联列表

<dl class="dl-horizontal">水平的定义列表
  <dt>Description 1</dt>
  <dd>Item 1</dd>
</dt>

<footer>From WWF's website</footer>

Bootstrap 允许您以两种方式显示代码：<code> 内联显示;  <pre> 独立的块元素

<table>
.table	为任意 <table> 添加基本样式 (只有横向分隔线)
.table-striped	在 <tbody> 内添加斑马线形式的条纹 ( IE8 不支持)
.table-bordered	为所有表格的单元格添加边框
.table-hover	在 <tbody> 内的任一行启用鼠标悬停状态
.table-condensed	让表格更加紧凑
可以联合使用所有表格类

<tr>, <th>, <td>
.active	将悬停的颜色应用在行或者单元格上
.success	表示成功的操作
.info	表示信息变化的操作
.warning	表示一个警告的操作
.danger	表示一个危险的操作


通过把任意的 .table 包在 .table-responsive class 元素内 得到 响应式表格
<div class="table-responsive">   <table class="table">。。。</table></div>

创建基本表单的步骤：
向父 <form> 元素添加 role="form"。
把标签和控件放在一个带有 class .form-group 的 <div> 中。这是获取最佳间距所必需的。
向所有的文本元素 <input>、<textarea> 和 <select> 添加 class .form-control。

请向 <form> 标签添加 class .form-inline 向左对齐的内联表单

向父 <form> 元素添加 class .form-horizontal。
把标签和控件放在一个带有 class .form-group 的 <div> 中。
向标签添加 class .control-label。 
将得到 标签和控件同行的表单。

 <input type="text" class="form-control" placeholder="文本输入">
 
 Bootstrap 提供了对所有原生的 HTML5 的 input 类型的支持，包括：text、password、datetime、datetime-local、date、month、time、week、number、email、url、search、tel 和 color。适当的 type 声明是必需的，这样才能让 input 获得完整的样式。
 <textarea class="form-control" rows="3"></textarea>
 
 <div class="checkbox">
   <label><input type="checkbox" value="">选项 1</label>
 </div>

 内联的复选框或单选按钮checkbox-inline
 <label class="checkbox-inline">
      <input type="checkbox" id="inlineCheckbox1" value="option1"> 选项 1
 </label>

 <select class="form-control">
 <select multiple class="form-control">
 
 当您需要在一个水平表单内的表单标签后放置纯文本时，请在 <p> 上使用 class .form-control-static。
 
 <label for="another input id">
 
 Bootstrap 包含了错误、警告和成功消息的验证样式。只需要对父元素简单地添加适当的 class（.has-warning、 .has-error 或 .has-success）即可使用验证状态。
 
 Bootstrap 表单控件可以在输入框 input 上有一个块级帮助文本。为了添加一个占用整个宽度的内容块，请在 <input> 后使用 .help-block 的span
 
 以下样式可用于<a>, <button>, 或 <input> 元素上：
.btn	为按钮添加基本样式
.btn-default	默认/标准按钮
.btn-primary	原始按钮样式（未被操作）
.btn-success	表示成功的动作
.btn-info	该样式可用于要弹出信息的按钮
.btn-warning	表示需要谨慎操作的按钮
.btn-danger	表示一个危险动作的按钮操作
.btn-link	让按钮看起来像个链接 (仍然保留按钮行为)
.btn-lg	制作一个大按钮
.btn-sm	制作一个小按钮
.btn-xs	制作一个超小按钮
.btn-block	块级按钮(拉伸至父元素100%的宽度)
.active	按钮被点击
.disabled	禁用按钮


<button type="button" class="btn btn-default btn-lg">默认按钮</button>

按钮元素	添加 .active class 来显示它是激活的。
锚元素	    添加 .active class 到 <a> 按钮来显示它是激活的。

按钮元素	添加 disabled 属性 到 <button> 按钮。
锚元素	添加 disabled class 到 <a> 按钮。 注意：该 class 只会改变 <a> 的外观，不会改变它的功能。在这里，您需要使用自定义的 JavaScript 来禁用链接。

 <a>、<button> 或 <input> 元素上使用按钮 class, 使得链接显示得像按钮。但是建议您在 <button> 元素上使用按钮 class，避免跨浏览器的不一致性问题

 Bootstrap 提供了三个可对图片应用简单样式的 class：
.img-rounded：添加 border-radius:6px 来获得图片圆角。
.img-circle：添加 border-radius:500px 来让整个图片变成圆形。
.img-thumbnail：添加一些内边距（padding）和一个灰色的边框。
.img-responsive	图片响应式 (将很好地扩展到父元素)

<a><p>
.bg-primary,.bg-success,.bg-info,.bg-warning,.bg-danger

.pull-left	元素浮动到左边
.pull-right	元素浮动到右边
.center-block	设置元素为 display:block 并居中显示
.clearfix	清除浮动	
.show	强制元素显示
.hidden	强制元素隐藏
.sr-only	除了屏幕阅读器外，其他设备上隐藏元素
.sr-only-focusable	与 .sr-only 类结合使用，在元素获取焦点时显示(如：键盘操作的用户)
.text-hide	将页面元素所包含的文本内容替换为背景图
.close	显示关闭按钮
.caret	显示下拉式功能

Bootstrap 提供了一些辅助类，以便更快地实现对移动设备友好的开发。这些可以通过媒体查询结合大型、小型和中型设备，实现内容对设备的显示和隐藏。
.visible-lg
.hidden-xs
..........

Bootstrap 字体图标(Glyphicons)
<button type="button" class="btn btn-primary btn-lg" style="font-size: 60px">
  <span class="glyphicon glyphicon-user"></span> User
</button>
http://www.runoob.com/try/demo_source/bootstrap-glyph-customization.htm

role, aria-*辅助访问标签， 用于读屏

下拉菜单的
<div class="dropdown">
   <button type="button" class="btn dropdown-toggle" id="dropdownMenu1" 
      data-toggle="dropdown">
      主题
      <span class="caret"></span>
   </button>
   <ul class="dropdown-menu" role="menu" >
      <li role="presentation" class="dropdown-header">下拉菜单标题</li>
      <li role="presentation" >
         <a role="menuitem" tabindex="-1" href="#">Java</a>
      </li>
      <li role="presentation" class="divider"></li>
      <li role="presentation" class="dropdown-header">下拉菜单标题</li>
      <li role="presentation">
         <a role="menuitem" tabindex="-1" href="#">分离的链接</a>
      </li>
   </ul>
</div>

按钮组
<div class="btn-group">
  <button type="button" class="btn btn-default">按钮 1</button>
  <button type="button" class="btn btn-default">按钮 2</button>
</div>

.btn-toolbar 有助于把几组 <div class="btn-group"> 结合到一个 <div class="btn-toolbar"> 中，一般获得更复杂的组件。	
<div class="btn-toolbar" role="toolbar">
  <div class="btn-group">...</div>
  <div class="btn-group">...</div>
</div>


.btn-group-lg, .btn-group-sm, .btn-group-xs	这些 class 可应用到整个按钮组的大小调整，而不需要对每个按钮进行大小调整。
.btn-group-vertical	该 class 让一组按钮垂直堆叠显示，而不是水平堆叠显示。

使用输入框组，您可以很容易地向基于文本的输入框添加作为前缀和后缀的文本或按钮
把前缀或后缀元素放在一个带有 class .input-group 的 <div> 中。
接着，在相同的 <div> 内，在 class 为 .input-group-addon 的 <span> 内放置额外的内容。

 .input-group-lg、input-group-sm、input-group-xs
 
 还可以把复选框和单选插件作为输入框组的前缀或者后缀元素
 <span class="input-group-addon"> <input type="checkbox"> </span>

 还可以把按钮作为输入框组的前缀或者后缀元素
 <span class="input-group-btn"><button class="btn btn-default" type="button">Go!</button></span>
 
 还可以把按钮菜单作为输入框组的前缀或者后缀元素
 <div class="input-group-btn">
                  <button type="button" class="btn btn-default" 
                     tabindex="-1">下拉菜单
                  </button>
                  <button type="button" class="btn btn-default 
                     dropdown-toggle" data-toggle="dropdown" tabindex="-1">
                     <span class="caret"></span>
                  </button>
                  <ul class="dropdown-menu pull-right">
                     <li><a href="#">功能</a></li>
                  </ul>
</div>		


创建一个的导航菜单：
以一个带有 class .nav 的无序列表开始。
.nav-tabs标签式，.nav-pills胶囊式, 可以在使用 class .nav、.nav-pills 的同时使用 class .nav-stacked，让胶囊垂直堆叠。同时使用 class .nav-justified，让标签式或胶囊式导航菜单与父元素等宽。在更小的屏幕上，导航链接会堆叠。
<ul class="nav nav-tabs">
   <li class="active"><a href="#">Home</a></li>
   <li><a href="#">SVN</a></li>
   <li><a  class="disabled" href="#">SVN</a></li>
</ul>
导航菜单可以嵌入下拉菜单。默认情况下，列表项的锚与一些数据属性协同合作来触发带有 .dropdown-menu class 的无序列表。

Bootstrap 导航栏
创建一个默认的导航栏的步骤如下：
向 <nav> 标签添加 class .navbar、.navbar-default。
向上面的元素添加 role="navigation"，有助于增加可访问性。
向 <div> 元素添加一个标题 class .navbar-header，内部包含了带有 class navbar-brand 的 <a> 元素。这会让文本看起来更大一号。
为了向导航栏添加链接，只需要简单地添加带有 class .nav、.navbar-nav 的无序列表即可。

面包屑导航（Breadcrumbs）是一种基于网站层次信息的显示方式
<ol class="breadcrumb">
  <li><a href="#">Home</a></li>
  <li><a href="#">2013</a></li>
  <li class="active">十一月</li>
</ol>

分页栏（Pagination）
<ul class="pagination">
  <li><a href="#">&laquo;</a></li>
  <li><a href="#">1</a></li>
  <li><a href="#">2</a></li>
  <li><a href="#">3</a></li>
  <li><a href="#">4</a></li>
  <li><a href="#">5</a></li>
  <li><a href="#">&raquo;</a></li>
</ul>

标签可用于计数、提示或页面上其他的标记显示
<span class="label label-default">默认标签</span>
label-default,label-primary,label-success,label-info,label-warning,label-danger

徽章（Badges)与标签相似，主要的区别在于徽章的边角更加圆滑。<span class="badge">new!</span>
可以在激活状态的胶囊式导航和列表导航中放置徽章

超大屏幕（Jumbotron）。顾名思义该组件可以增加标题的大小，并为登陆页面内容添加更多的外边距（margin）。使用超大屏幕（Jumbotron）的步骤如下：
创建一个带有 class .jumbotron. 的容器 <div>。

页面标题（Page Header）
<div class="page-header">
   <h1>页面标题实例
      <small>子标题</small>
   </h1>
</div>
   
创建一个 <div>，并向其添加一个 .alert class 和四个上下文 class（即 .alert-success、.alert-info、.alert-warning、.alert-danger）之一，来添加一个基本的警告框。

可取消的警告（Dismissal Alerts）
<div class="alert alert-success alert-dismissable">
   <button type="button" class="close" data-dismiss="alert" 
      aria-hidden="true">
      &times;
   </button>
   成功！很好地完成了提交。
</div>

在警告（Alerts）中创建链接
<div class="alert alert-success">
   <a href="#" class="alert-link">成功！很好地完成了提交。</a>
</div>

进度条
<div class="progress  progress-striped active">
   <div class="progress-bar" role="progressbar"  style="width: 40%;">
      <span class="sr-only">40% 完成</span>
   </div>
</div>

添加一个带有 class .progress-bar 和 class progress-bar-* 的空的 <div>。其中，* 可以是 success、info、warning、danger。

多媒体对象（Media Object）。这些抽象的对象样式用于创建各种类型的组件（比如：博客评论），我们可以在组件中使用图文混排，图像可以左对齐或者右对齐。媒体对象可以用更少的代码来实现媒体对象与文字的混排。

Bootstrap 面板（Panels）。面板组件用于把 DOM 组件插入到一个盒子中。创建一个基本的面板，只需要向 <div> 元素添加 class .panel 和 class .panel-default 即可


jQuery库包含以下功能：
HTML 元素选取
HTML 元素操作
CSS 操作
HTML 事件函数
JavaScript 特效和动画
HTML DOM 遍历和修改
AJAX
Utilities
提示： 除此之外，Jquery还提供了大量的插件。

jQuery 选择器

$("*")	选取所有元素
$(this)	选取当前 HTML 元素
$("p.intro")	选取 class 为 intro 的 <p> 元素
$("p:first")	选取第一个 <p> 元素
$("ul li:first")	选取第一个 <ul> 元素的第一个 <li> 元素
$("ul li:first-child")	选取每个 <ul> 元素的第一个 <li> 元素
$("[href]")	选取带有 href 属性的元素
$("a[target='_blank']")	选取所有 target 属性值等于 "_blank" 的 <a> 元素
$("a[target!='_blank']")	选取所有 target 属性值不等于 "_blank" 的 <a> 元素
$(":button")	选取所有 type="button" 的 <input> 元素 和 <button> 元素
$("tr:even")	选取偶数位置的 <tr> 元素
$("tr:odd")	选取奇数位置的 <tr> 元素


元素选择器 $("p#demo")
属性选择器
$("[href='#']") 选取所有带有 href 值等于 "#" 的元素。
CSS 选择器
$("p").css("background-color","red");
$("ul li:first")	每个 <ul> 的第一个 <li> 元素

.ex 的子元素 .hide,  事件动作隐藏.ex父结点
$(".ex .hide").click(function(){
    $(this).parents(".ex").hide("slow");
  }); 

通过 jQuery，您可以使用 toggle() 方法来切换 hide() 和 show() 方法。

fadeIn(),fadeOut(),fadeToggle(),fadeTo()  
slideDown(),slideUp(),slideToggle()
animate() 方法用于创建自定义CSS 动画。
$("button").click(function(){
  var div=$("div");
  div.animate({height:'300px',opacity:'0.4'},"slow");
  div.animate({width:'300px',opacity:'0.8'},"slow");
  div.animate({height:'100px',opacity:'0.4'},"slow");
  div.animate({width:'100px',opacity:'0.8'},"slow");
});


jQuery stop() 在动画完成之前停止,适用于所有 jQuery 效果函数，包括滑动、淡入淡出和自定义动画。

由于 JavaScript 单线程的， 需要使用 Callback 函数。
$(selector).hide(speed,callback)

下面的例子把 css(), slideUp(), and slideDown() 链接在一起。"p1" 元素首先会变为红色，然后向上滑动，然后向下滑动：
$("#p1").css("color","red").slideUp(2000).slideDown(2000);


简单实用的用于 DOM 操作的 jQuery 方法：
text() - 设置或返回所选元素的文本内容
html() - 设置或返回所选元素的内容（包括 HTML 标记）
val() - 设置或返回表单字段的值
attr("href")


添加新内容的四个 jQuery 方法：
append() - 在被选元素的结尾插入内容
prepend() - 在被选元素的开头插入内容
after() - 在被选元素之后插入内容
before() - 在被选元素之前插入内容

remove() - 删除被选元素（及其子元素）
empty() - 从被选元素中删除子元素

$("p").remove(".italic");


addClass() - 向被选元素添加一个或多个类
removeClass() - 从被选元素删除一个或多个类
toggleClass() - 对被选元素进行添加/删除类的切换操作
css() - 设置或返回样式属性

parent()
parents()
parentsUntil()

children() 方法返回被选元素的所有直接子元素。
  $("div").children("p.1");
find() 方法返回被选元素的后代元素，一路向下直到最后一个后代。
  $("div").find("span");

有许多有用的方法让我们在 DOM 树进行水平遍历：
siblings()
next()
nextAll()
nextUntil()
prev()
prevAll()
prevUntil()

过滤方法是：first(), last() ,eq()，filter() 和 not() 
  

load() AJAX 方法从服务器加载数据，并把返回的数据放入被选元素中。
$(selector).load(URL,data,callback);  

$.get(URL,callback); 方法通过 HTTP GET 请求从服务器上请求数据。
$.post(URL,data,callback); HTTP POST 请求从服务器上请求数据。


jQuery 事件方法会触发匹配元素的事件，或将函数绑定到所有匹配元素的某个事件。

触发 $("button#demo").click()
绑定实例 $("button#demo").click(function(){$("img").hide()})


CSS3 边框
border-radius
box-shadow
border-image

div是块级元素，在页面中独占一行，自上而下排列，也就是传说中的流

pivot table with javascript
http://nicolas.kruchten.com/pivottable/examples/

DataTables 
https://datatables.net/

table tr:nth-child(odd)	{
  background-color: #f1f1f1;
}
table tr:nth-child(even) {
  background-color: #ffffff;
}

js 
未使用值来声明的变量，其值实际上是 undefined
JavaScript 拥有动态类型。这意味着相同的变量可用作不同的类型

数组
var cars=new Array();
cars[0]="Saab";cars[1]="Volvo";
--
var cars=new Array("Saab","Volvo","BMW");
---
var cars=["Saab","Volvo","BMW"];

对象
var person={firstname:"John", lastname:"Doe", id:5566};
定义 JavaScript 对象可以跨越多行，空格跟换行不是必须的：
var person = {
    firstName:"John",
    lastName:"Doe",
    age:50,
    eyeColor:"blue",
	fullName: function () {
        return this.firstName + " " + this.lastName;
    }
};

对象属性有两种寻址方式：
name=person.lastname;
name=person["lastname"];

Undefined 这个值表示变量不含有值。
可以通过将变量的值设置为 null 来清空变量。
cars=null;

当您声明新变量时，可以使用关键词 "new" 来声明其类型：
var carname=new String;
var x=      new Number;
var y=      new Boolean;
var cars=   new Array;
var person= new Object;

如果您把值赋给尚未声明的变量，该变量将被自动作为全局变量声明。
carname="Volvo";  将声明一个全局变量 carname(未使用var)，即使它在函数内执行。

使用在函数内var 关键字为局部变量。

在 HTML 中, 全局变量是 window 对象: 所有数据变量都属于 window 对象。

JavaScript 字符串是原始值，可以使用字符创建： var firstName = "John"
但我们也可以使用 new 关键字将字符串定义为一个对象： var firstName = new String("John")

var x = "John";
var y = new String("John");
typeof x // 返回 String
typeof y // 返回 Object

不要创建 String 对象。它会拖慢执行速度，并可能产生其他副作用：

===	绝对等于（值和类型均相等）

JavaScript for/in 语句循环遍历对象的属性：
实例
var person={fname:"John",lname:"Doe",age:25}; 

for (x in person)
  {
  txt=txt + person[x];
  }

typeof "John"                // 返回 string 
typeof 3.14                  // 返回 number
typeof false                 // 返回 boolean
typeof [1,2,3,4]             // 返回 object
typeof {name:'John', age:34} // 返回 object
typeof NaN                    // 返回 number

你可以设置为 null 来清空对象:
var person = null;           // Value is null, but type is still an object  

你可以设置为 undefined 来清空对象:
var person = undefined;     // 值为 undefined, type is undefined 

typeof undefined             // undefined
typeof null                  // object
null === undefined           // false
null == undefined            // true

在 JavaScript 中有 5 中不同的数据类型：
string
number
boolean
object
function
3 种对象类型：
Object
Date
Array
2 个不包含任何值的数据类型：
null
undefined

constructor 属性返回所有 JavaScript 变量的构造函数。
"John".constructor                 // 返回函数 String()  { [native code] }
(3.14).constructor                 // 返回函数 Number()  { [native code] }
false.constructor                  // 返回函数 Boolean() { [native code] }
[1,2,3,4].constructor              // 返回函数 Array()   { [native code] }
{name:'John', age:34}.constructor  // 返回函数 Object()  { [native code] }
new Date().constructor             // 返回函数 Date()    { [native code] }
function () {}.constructor         // 返回函数 Function(){ [native code] }


如果对象是 JavaScript Array 或 JavaScript Date ，我们就无法通过 typeof 来判断他们的类型，因为都是 返回 Object

你可以使用 constructor 属性来查看是对象是否为数组 (包含字符串 "Array"):
function isArray(myArray) {
    return myArray.constructor.toString().indexOf("Array") > -1;
}

你可以使用 constructor 属性来查看是对象是否为日期 (包含字符串 "Date"):
function isDate(myDate) {
    return myDate.constructor.toString().indexOf("Date") > -1;
}

全局方法 String() 可以将数字/..转换为字符串。
 String(123)
 String(false)
 String(Date())

 toString() 也有相同的效果。
(100 + 23).toString()
false.toString()     // 返回 "false"
Date().toString()

全局方法 Number() 可以将字符串/boolean/Date转换为数字。
Number("3.14")    // 返回 3.14
Number(" ")       // 返回 0 
Number("99 88")   // 返回 NaN 
Number(false)     // 返回 0
Number(true)      // 返回 1

Number(new Date()) // 返回 1404568027739

全局方法
parseFloat()	解析一个字符串，并返回一个浮点数。
parseInt()	解析一个字符串，并返回一个整数。

当 JavaScript 尝试操作一个 "错误" 的数据类型时，会自动转换为 "正确" 的数据类型。
以下输出结果不是你所期望的：
5 + null    // 返回 5         because null is converted to 0
"5" + null  // 返回"5null"   because null is converted to "null"
"5" + 1     // 返回 "51"      because 1 is converted to "1"  
"5" - 1     // 返回 4         because "5" is converted to 5

在 JavaScript 中，正则表达式通常用于两个字符串方法 : search() 和 replace()。

try
  {
  //在这里运行代码
  }
catch(err)
  {
  //在这里处理错误
  }
 
 console.log() 方法
 
 debugger 关键字用于停止执行 JavaScript，并调用调试函数。
这个关键字与在调试工具中设置断点的效果是一样的。

var x=document.forms["myForm"]["fname"].value;

onsubmit="return validateForm()"
函数用来检查用户是否已填写表单,并且函数的返回值为 false，否则函数的返回值则为 true（意味着数据没有问题）

javascript:void(0) 中最关键的是 void 关键字， void 是 JavaScript 中非常重要的关键字，该操作符指定要计算一个表达式但是不返回值。

href="#"与href="javascript:void(0)"的区别
# 包含了一个位置信息，默认的锚是#top 也就是网页的上端。
而javascript:void(0), 仅仅表示一个死链接。
在页面很长的时候会使用 # 来定位页面的具体位置，格式为：# + id。

函数声明 
function functionName(parameters) {
  执行的代码
}
函数表达式
JavaScript 函数可以通过一个表达式定义。
函数表达式可以存储在变量中：
var x = function (a, b) {return a * b};

函数同样可以通过内置的 JavaScript 函数构造器（Function()）定义。
var myFunction = new Function("a", "b", "return a * b");

实际上，你不必使用构造函数。上面实例可以写成：
var myFunction = function (a, b) {return a * b}

提升（Hoisting）是 JavaScript 默认将当前作用域提升到前面去的的行为。应用在变量的声明与函数的声明。
因此，函数可以在声明之前调用：
myFunction(5);

function myFunction(y) {
    return y * y;
}
使用表达式定义函数时无法提升

函数表达式可以 "自调用"
(function () {
    var x = "Hello!!";      // 我将调用自己
})();
 
在 JavaScript 中使用 typeof 操作符判断函数类型将返回 "function" 。
但是JavaScript 函数描述为一个对象更加准确。
JavaScript 函数有 属性 和 方法。
arguments.length 属性返回函数调用过程接收到的参数个数：
实例
function myFunction(a, b) {
    return arguments.length;
}

如果函数在调用时缺少参数，参数会默认设置为： undefined
function myFunction(x, y) {
    y = y || 0;
}
如果y已经定义 ， y || 返回 y, 因为 y 是 true, 否则返回 0, 因为 undefined 为 false

通过值传递参数
在函数中调用的参数是函数的参数。
如果函数修改参数的值，将不会修改参数的初始值（在函数外定义）。
函数参数的改变不会影响函数外部的变量（局部变量）。
通过对象传递参数
在JavaScript中，可以引用对象的值。
因此我们在函数内部修改对象的属性就会修改其初始的值。
修改对象属性可作用于函数外部（全局变量）。

使用构造函数调用函数
如果函数调用前使用了 new 关键字, 则是调用了构造函数。
这看起来就像创建了新的函数，但实际上 JavaScript 函数是重新创建的对象：
实例
// 构造函数:
function myFunction(arg1, arg2) {
    this.firstName = arg1;
    this.lastName  = arg2;
}

// This	creates a new object
var x = new myFunction("John","Doe");
x.firstName;                             // 返回 "John"


在 JavaScript 中, 函数是对象。JavaScript 函数有它的属性和方法。
call() 和 apply() 是预定义的函数方法。 两个方法可用于调用函数，两个方法的第一个参数必须是对象本身。
实例
function myFunction(a, b) {
    return this+a * b;
}
myFunction.call("prefix", 10, 2);      // 返回 prefix20, 类似Java中的方法反射调用,  第一个参数转为this.

apply功能是一样的, 只是传入的是一个参数数组，也就是将多个参数组合成为一个数组传入，而call则作为call的参数传入（从第二个参数开始）。

在 JavaScript 严格模式(strict mode)下, 在调用函数时第一个参数会成为 this 的值， 即使该参数不是一个对象。
在 JavaScript 非严格模式(non-strict mode)下, 如果第一个参数的值是 null 或 undefined, 它将使用全局对象替代。

闭包
var add = (function () {
    var counter = 0;
    return function () {return counter += 1;}
})();

function myFunction(){
    document.getElementById("demo").innerHTML = add();
}

document.getElementsByClassName("intro");
document.getElementById("main");
document.getElementById("p2").style.color="blue";


document.getElementById("myBtn").onclick=function(){displayDate()};
document.getElementById("myBtn").addEventListener("click", displayDate);


var para=document.createElement("p");
var node=document.createTextNode("This is new.");
para.appendChild(node);

var element=document.getElementById("div1");
element.appendChild(para);

parent.removeChild(child);

创建实例
person=new Object();
person.firstname="John";
person.lastname="Doe";

person={firstname:"John",lastname:"Doe",age:50,eyecolor:"blue"};

function person(firstname,lastname,age,eyecolor)
{
this.firstname=firstname;
this.lastname=lastname;
this.age=age;
this.eyecolor=eyecolor;
}
var myFather=new person("John","Doe",50,"blue");

JavaScript 类
JavaScript 是面向对象的语言，但 JavaScript 不使用类。
在 JavaScript 中，不会创建类，也不会通过类来创建对象（就像在其他面向对象的语言中那样）。
JavaScript 基于 prototype，而不是基于类的


txt="a,b,c,d,e"   // String
txt.split(",");   // Split on commas

使用Math的属性/方法的语法：
var x=Math.PI;
var y=Math.sqrt(16);

浏览器对象模型（Browser Object Model (BOM)）

<script>

txt = "<p>Browser CodeName: " + navigator.appCodeName + "</p>";
txt+= "<p>Browser Name: " + navigator.appName + "</p>";
txt+= "<p>Browser Version: " + navigator.appVersion + "</p>";
txt+= "<p>Cookies Enabled: " + navigator.cookieEnabled + "</p>";
txt+= "<p>Platform: " + navigator.platform + "</p>";
txt+= "<p>User-agent header: " + navigator.userAgent + "</p>";
txt+= "<p>User-agent language: " + navigator.systemLanguage + "</p>";

document.getElementById("example").innerHTML=txt;

alert(), prompt()

myVar=setInterval() - 间隔指定的毫秒数不停地执行指定的代码。
setTimeout() - 暂停指定的毫秒数后执行指定的代码

window.clearInterval(intervalVariable)

设置 cookie 值的函数
首先，我们创建一个函数用于存储访问者的名字：
function setCookie(cname,cvalue,exdays)
{
var d = new Date();
d.setTime(d.getTime()+(exdays*24*60*60*1000));
var expires = "expires="+d.toGMTString();
document.cookie = cname + "=" + cvalue + "; " + expires;
}


AngularJS 把应用程序数据绑定到 HTML 元素。
AngularJS 可以克隆和重复 HTML 元素。
AngularJS 可以隐藏和显示 HTML 元素。
AngularJS 可以在 HTML 元素"背后"添加代码。
AngularJS 支持输入验证。

ng-app 指令
ng-app 指令定义了 AngularJS 应用程序的 根元素。
ng-app 指令在网页加载完毕时会自动引导（自动初始化）应用程序。
稍后您将学习到 ng-app 如何通过一个值（比如 ng-app="myModule"）连接到代码模块。
ng-init 指令
ng-init 指令为 AngularJS 应用程序定义了 初始值。
通常情况下，不使用 ng-init。您将使用一个控制器或模块来代替它。
稍后您将学习更多有关控制器和模块的知识。
ng-model 指令 绑定 HTML 元素 到应用程序数据。
ng-model 指令也可以：
为应用程序数据提供类型验证（number、email、required）。
为应用程序数据提供状态（invalid、dirty、touched、error）。
为 HTML 元素提供 CSS 类。
绑定 HTML 元素到 HTML 表单。
ng-repeat 指令对于集合中（数组中）的每个项会 克隆一次 HTML 元素。 其可以使用 $index ,$odd,$even

<table>
<tr ng-repeat="x in names">
<td ng-if="$odd" style="background-color:#f1f1f1">{{ x.Name }}</td>
<td ng-if="$even">{{ x.Name }}</td>
<td ng-if="$odd" style="background-color:#f1f1f1">{{ x.Country }}</td>
<td ng-if="$even">{{ x.Country }}</td>
</tr>
</table>


<button ng-disabled="mySwitch">点我！</button>
ng-disabled 指令绑定应用程序数据 "mySwitch" 到 HTML 的 disabled 属性。

<p ng-show="true">我是可见的。</p>
<p ng-show="false">我是不可见的。</p>
<p ng-hide="true">我是不可见的。</p>
<p ng-hide="false">我是可见的。</p>


$scope.$watch('passw1',function() {$scope.test();});


<button ng-click="count = count + 1">点我！</button>

var app = angular.module('myApp', []);
app.controller('formCtrl', function($scope) {
    $scope.master = {firstName: "John", lastName: "Doe"};
    $scope.reset = function() {
        $scope.user = angular.copy($scope.master);
    };
    $scope.reset();
});

form
novalidate 属性是在 HTML5 中新增的。禁用了使用浏览器的默认验证。


<form  ng-app="myApp"  ng-controller="validateCtrl"
name="myForm" novalidate>

<p>邮箱:<br>
  <input type="email" name="email" ng-model="email" required>
  <span style="color:red" ng-show="myForm.email.$dirty && myForm.email.$invalid">
  <span ng-show="myForm.email.$error.required">邮箱是必须的。</span>
  <span ng-show="myForm.email.$error.email">非法的邮箱。</span>
  </span>
</p>

<p>
  <input type="submit"
  ng-disabled="myForm.email.$invalid">
</p>

</form>

$scope.$watch('passw1',function() {$scope.test();});

<div class="container">
  <div ng-include="'myUsers_List.htm'"></div>
  <div ng-include="'myUsers_Form.htm'"></div>
</div>


var app = angular.module('myApp', []);
app.controller('customersCtrl', function($scope, $http) {
    $http.get("http://www.runoob.com/try/angularjs/data/Customers_JSON.php")
    .success(function(response) {$scope.names = response.records;});
});


我们同样为每条记录添加手机图片，只需要使用ngSrc指令代替<img>的src属性标签就可以了。如果我们仅仅用一个正常src属性来进行绑定（<img class="diagram" src="{{phone.imageUrl}}">），浏览器会把AngularJS的{{ 表达式 }}标记直接进行字面解释，并且发起一个向非法urlhttp://localhost:8000/app/{{phone.imageUrl}}的请求。因为浏览器载入页面时，同时也会请求载入图片，AngularJS在页面载入完毕时才开始编译——浏览器请求载入图片时{{phone.imageUrl}}还没得到编译！有了这个ngSrc指令会避免产生这种情况，使用ngSrc指令防止浏览器产生一个指向非法地址的请求。

使用ng-view.这个方法通过使用路由控制，可以方便的实现页面组合。但这个方法也有一个重大缺点，就是一个html文件中，只能有一个ng-view。虽然有变通之法。他是可以被ctl控制的。
ng-include就是将多个页面的公共页面提取出来，如header.html，footer.html等，在每个页面用<dv ng-include="header.html"></div>来引入

The event can be broadcasted to the scope children or emitted to scope parents.
$emit('MyEvent')
$broadcast('MyEvent')

$scope.$on('MyEvent', function() {
    $scope.count++;
  });
  
  

n00bs
Noob is short for newbie or new to the game. Its not a bad term. HOWEVER, a NOOB is someone who is idiotic because he is new, a NUB is someone who has had the opportunity to learn something new, but never did, and is therefore idiotic/stupid.

HttpsURLConnection.setDefaultHostnameVerifier(allHostsValid);  

keytool -printcert -sslserver playframework.com


sbt-native-packager



logger.debug("Entry number: " + i + " is " + String.valueOf(entry[i]));
即使logger的设定级别是Error,  此参数的字符串转化拼接都将影响性能。

改善代码如下。
if(logger.isDebugEnabled()) { 
  logger.debug("Entry number: " + i + " is " + String.valueOf(entry[i]));
}

更好的选择。
Object entry = new SomeObject(); 
logger.debug("The new entry is {}. It replaces {}.", entry, oldEntry);

猜测logback内部使用stringformat,  因其性能奇差。

logback.groovy>logback-test.xml>logback.xml>default setting,
If you are using Maven and if you place the logback-test.xml under the src/test/resources folder, Maven will ensure that it won't be included in the artifact produced. Thus, you can use a different configuration file, namely logback-test.xml during testing.

Setting the debug attribute within the <configuration> element will output status information, assuming 

-Dlogback.configurationFile=/path/to/config.xml

In order to instruct logback-classic to scan for changes in its configuration file and to automatically re-configure itself set the scan attribute of the <configuration> element to true

when a configuration file changes, it will be automatically reloaded but only after several logger invocations and after a delay determined by the scanning period to reduce  performance penalt.

Postman:
Create and send any HTTP request using the awesome Postman Builder

Batarang 是用于开发和调试 AngularJS 应用的一个优秀的chrome浏览器插件。

build-your-own-angularjs

Javascript MVVM
AngularJS
MeteorJS
Polymer
React


http://ngmodules.org/




function createCounter(counterName) {
  var counter = 0;
 
  function increment() {
    counter = counter + 1;
 
    console.log("Number of " + counterName + ": " + counter);
  };
 
  function decrement() {
    counter = counter - 1;
 
    console.log("Number of " + counterName + ": " + counter);
  };
 
  return {
    increment : increment,
    decrement : decrement
  };
}


var dogsCounter = createCounter("dogs");
 
dogsCounter.increment(); // Number of dogs: 1
dogsCounter.increment(); // Number of dogs: 2
dogsCounter.decrement(); // Number of dogs: 1


qrcode   js generate cr 二维码

2014-01-01-readingList.md
---
layout: post
title: 读书列表
comments: false
keywords: 读书
category: 读书
---

cpu cores:
cat /proc/cpuinfo|grep processor|wc -l
/usr/bin/kstat -m cpu_info|grep core_id|sort -u|wc -l

total mem
 cat /proc/meminfo |grep MemTotal
 
 
Ionic是一套开源前端框架，旨在利用HTML、CSS以及JavaScript实现移动应用程序开发
AngularUI
Mobile Angular UI
AngularStrap
AngularJS 认证模块 Satellizer
WebStorm
Jasmine
 

简单说，Source map就是一个信息文件，里面储存着位置信息。也就是说，转换后的js代码的每一个位置，所对应的转换前的位置。

HTML5 Cross Browser Polyfills 
 
 
 angular-block-ui   angularAMD  angular-form-gen 
 
livereload
 
Unix4j

BSON与MessagePack（与JSON）

JSON Web Token (JWT)

OpenShift/heroku/阿里百川

Isotope ,headroom ,  cslider, angular-datatables
CodeMirror是一个利用JavaScript实现代码编辑器

cmder,   an alternative cmd for windows.


jta timeout 600->10
Stuck Thread Max Time:  600->120
Stuck Thread Timer Interval:60->30




输出仅取决于输入的参数,对于这样的函数，我们又称之为纯函数（Pure function），这个概念非常地重要, 没有副作用的

面向对象里， 每次在对象内部的属性变化的时候，我们不直接修改这个对象，而是返回一个新的对象。
Immutable.js
 
 

alter session set events 'immediate trace name flush_cache level 1';

数据库表中数据存储都是以块为单位，称为数据块；表中每行数据都有唯一的地址标志ROWID。

SQL进行索引扫描，在索引中找到符合条件记录的位置（rowid），根据rowid再查询数据(这就是回表)，如果数据量少，那么回表次数就少，如果需要的数据全部在索引中，那么就不会再回表了.
例如分页需要回表，一般尽量在索引上分页，然后返回rowid，再通过rowid进行回表查询
Select * from table t,   
(select rid from (select rowid rid,row_number over(order by a) rn from table where b=? And c=?)   
 where rn>=1 and rn<=20) tmp   
Where tmp.rid=t.rowid  

index join顾名思义是对index进行关联,oracle通过hash index join的方式实现了避免对表的访问.所有的数据都从索引中直接获得.它不受查询条件影响,可以是唯一索引,也可以是多列索引.

虚拟的表(子查询...)，没有准确的统计信息，很容易出现执行计划错误

use_nl不能让优化器确定谁是驱动表谁是被驱动的表,use_nl(t,t2)也没有指出哪个是驱动表，这时候我们需要使用ordered,leading来强制指定驱动表，以达到我们的目的。

ALL_ROWS/FIRST_ROWSn

表之间的连接可分为hash Join， Nested loops，Sort Merge Join

Nested loops要把返回子集较小表的作为外表（CBO 默认外表是驱动表），而且在内表的连接字段上一般要有索引
hash Join是CBO 做大数据集连接时的常用方式，优化器使用两个表中较小的表（或数据源）利用连接键在内存中建立散列表，然后扫描较大的表并探测散列表，找出与散列表匹配的行。
SORT MERGE JOIN 通常情况下散列连接的效果都比排序合并连接要好，然而如果行源已经被排过序，这时排序合并连接的性能会优于散列连接。可以使用USE_MERGE(table_name1 table_name2)来强制使用排序合并连接.Sort Merge join 适用在没有索引，并且数据已经排序的情况

ORACLE 采用三种访问表中记录的方式: 全表扫描、通过ROWID访问表、索引扫描
ORACLE利用多块读的方法十分高效地实现全表扫描。
在索引中，除了存储每个索引的值外，索引还存储具有此值的行对应的ROWID值。索引扫描可以由2步组成：(1) 扫描索引得到对应的rowid值。 (2) 通过找到的rowid从表中读出具体的数据。

index skip scan(索引跳跃式扫描)
当查询可以通过组合索引得到结果，而且返回结果很少，并且where条件中没有包含索引引导列的时候，可能执行index skip scan。

索引跳跃式扫描发生的条件:
必须是组合索引。
引导列没有出现在where条件中。

select  *
From a,b,c,d
Where ...

oracle 10g中, hash_join可以通过no_swap_join_inputs/swap_join_inputs来强制控制build表，配合leading或者ordered可以控制多表之前的连接顺序。
( T3 hash-join (T1 hash-join T2)) hash-join T4
       /*+
       leading(t1 t2 t3 t4)
       use_hash(t2)
       use_hash(t3)
       swap_join_inputs(t3)
       use_hash(t4)
       no_swap_join_inputs(t4)
       */ 


select a.*  from emp a,dept b where a.deptno = b.deptno and exists (select 1 from dept1 where dept1.dname = b.dname);
由于dept1记录较少， (select 1 from dept1 where dept1.dname = b.dname) 会返回非常少的数据。但Oracle一般会先连接a.deptno = b.deptno
PUSH_SUBQ 可以用来控制子查询的执行  select /*+ push_subq */

/*+ qb_name (queryblock ) */ qb_name是定义一个查询模块的别名的意思:

select * from table(dbms_xplan.display(null, null, 'outline'));  会返回上次SQL的执行路径。

Oracle 插入大量数据
1，用Hint 提示减少操作时间，INSERT   /*+Append*/   INTO     tab1 SELECT   *   FROM   tab2;
2，修改表为不写日志， alter   table   table_name   NOLOGGING;   insert into xxx
	
	
	
当SQL执行前，通过Statement.setQueryTimeout(int)时（参数单位为秒），这个参数的值只要不是0，它就会在JDBC内部与MySQL通信前会创建一个任务，这个任务会放入到一个Timer的任务队列中.
1、如果SQL语句在CancelTask还未被Timer调度前响应，则会在JDBC代码中执行调用CancelTask.cancel()方法。
2、如果SQL语句一直未响应，CancelTask在达到设置的设置的timeout值时会一般会被Timer调度，如果已经是cancel状态不执行取消SQL执行操作，直接从队列中移除，如果CancelTask还没有被cancel，则会向MySQL发送相应的取消命令，让其回收资源。Timer在调度这个任务的时候CancelTask内部会创建新的线程来处理，因此Timer很快就会认为任务执行完了，也就是和取消SQL本身的时间无关，Timer也会将这个任务对象从队列中移除，因为这个任务并不是循环执行的。

3、如果Statement.setQueryTimeout(int)这个值设置得非常大。
2、当大批量的SQL同时执行时，每一个SQL都会创建一个CancelTask对象，虽然很快执行完，且会调用CancelTask.cancel()方法，但是CancelTask方法的源代码仅仅是将自己的状态修改为：CANCELLED，而并不会直接从队列中移除这个对象，只有等到超过queryTimeout的值时被Timer调度，才会从队列中移除。

大量的CancelTask造成OOM

httpClient3.1支持3种timeout的设置：
connectionTimeout  :  socket建立链接的超时时间，Httpclient包中通过一个异步线程去创建socket链接，对应的超时控制。
timeoutInMilliseconds :  socket read数据的超时时间， socket.setSoTimeout(timeout);
httpConnectionTimeout :  如果那个的是MultiThreadedHttpConnectionManager，对应的是从连接池获取链接的超时时间。

JDBC  Timeout
1.Statement.setQueryTimeout()
2.Txn  timeout
3.driver socket timeout.(somehow socket can not detect connection broken,  this timeout can help app to restore from unpredictable condition)
  normally jdbc specify  socket timeout via jdbc url.(loginTimeout{connection setup},socketTimeout{io.read/write})
  
  
  
	
